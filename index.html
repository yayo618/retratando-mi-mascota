<html>
  <head></head>
  <body>
    <div>
	<button onclick="stop(),nStopM(),moverIzq=true">mover izq</button>
	<button onclick="stop()">stop</button>
	<button onclick="stop(),nStopM(),moverDer=true">mover der</button>
	<button onclick="stop(),nStopM(),moverAde=true">mover ade</button>
	<button onclick="stop(),nStopM(),moverAtr=true">mover atr</button>
	<button onclick="stop(),rotaIz=true">gira izq</button>
	<button onclick="stop(),rotaDe=true">gira der</button>
    </div>
    <script src="../threejs/three.min.js"></script>
    <script>
	var moverIzq,moverDer,moverAde,moverAtr,rotaIz,rotaDe;
	var clock = new THREE.Clock();
	var blockZn = true;
	var blockZp = true;
	var blockXn = true;
	var blockXp = true;
	var lblockZn = true;
	var lblockZp = true;
	var lblockXn = true;
	var lblockXp = true;

	var scene, camera, renderer;
	scene = new THREE.Scene();
	camera = new THREE.PerspectiveCamera(60,
		window.innerWidth/window.innerHeight);
	//camera.position.set( 0, 0, 0.5 );
	//camera.rotation.y += Math.PI;
        renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth,window.innerHeight);
        document.body.appendChild(renderer.domElement);


	var cube = new THREE.Mesh(
                new THREE.BoxGeometry(0.5,0.5,0.25),
        	new THREE.MeshBasicMaterial({color:0x00ff00}));
	cube.position.set(1,0,5.5);
        scene.add(cube);

	meshFloor = new THREE.Mesh( 
	            new THREE.PlaneGeometry(20,20,20,20),
 		    new THREE.MeshBasicMaterial({color:0xffffff,wireframe:true})
 	);
	meshFloor.rotation.x -= Math.PI/2;
	meshFloor.position.y = -1;
	meshFloor.receiveShadow = true;
	scene.add(meshFloor);

	//collision helper
	var paredH1 = new THREE.Mesh(
                new THREE.PlaneGeometry(10,0.2),
                new THREE.MeshBasicMaterial({color:0x00ff00,wireframe:true}));
	paredH1.rotation.y -= Math.PI/2;
	paredH1.position.x = -5;
	scene.add(paredH1);
	var paredH2 = new THREE.Mesh(
                new THREE.PlaneGeometry(10,0.2),
                new THREE.MeshBasicMaterial({color:0x00ff00,wireframe:true}));
	paredH2.rotation.y += Math.PI/2;
	paredH2.position.x = 5;
	scene.add(paredH2);
	var paredH3 = new THREE.Mesh(
                new THREE.PlaneGeometry(10,0.2),
                new THREE.MeshBasicMaterial({color:0x00ff00,wireframe:true}));
	paredH3.position.z = 5;
	scene.add(paredH3);
	var paredH4 = new THREE.Mesh(
                new THREE.PlaneGeometry(10,0.2),
                new THREE.MeshBasicMaterial({color:0x00ff00,wireframe:true}));
	paredH4.position.z = -5;
	scene.add(paredH4);
	var paredH5 = new THREE.Mesh(
                new THREE.PlaneGeometry(4,0.05),
                new THREE.MeshBasicMaterial({color:0x0000ff}));
	paredH5.position.set(-3,0,-1);
	scene.add(paredH5);
	var paredH6 = new THREE.Mesh(
                new THREE.PlaneGeometry(4,0.05),
                new THREE.MeshBasicMaterial({color:0x0000a0}));
	paredH6.rotation.y += Math.PI/2;
	paredH6.position.set(-1,0,-3);
	scene.add(paredH6);

	renderer.render( scene, camera );

	var stop = function(){
	  moverIzq=false;
	  moverDer=false;
	  moverAde=false;
	  moverAtr=false;
	  rotaIz=false;
	  rotaDe=false;
	}
	var nStopM = function(){
	  blockZp=true;
	  blockZn=true;
	  blockXp=true;
	  blockXn=true;
	  lblockZp=true;
	  lblockZn=true;
	  lblockXp=true;
	  lblockXn=true;
	}

	var restringeMZN = function (){
	    if(Math.cos(camera.rotation.y)>0){blockZn=false;}
	    else if(Math.cos(camera.rotation.y)<0){blockZp=false;}
	}
	var restringeMZNL = function (){
	    if(Math.sin(camera.rotation.y)>0){lblockZp=false;}
	    else if(Math.sin(camera.rotation.y)<0){lblockZn=false;}
	}
	var restringeMZP = function (){
	    if(Math.cos(camera.rotation.y)>0){blockZp=false;}
	    else if(Math.cos(camera.rotation.y)<0){blockZn=false;}
	}
	var restringeMZPL = function (){
	    if(Math.sin(camera.rotation.y)>0){lblockZn=false;}
	    else if(Math.sin(camera.rotation.y)<0){lblockZp=false;}
	}
	var restringeMXN = function (){
	    if(Math.sin(camera.rotation.y)>0){blockXn=false;}
	    else if(Math.sin(camera.rotation.y)<0){blockXp=false;}
	}
	var restringeMXNL = function (){
	    if(Math.cos(camera.rotation.y)>0){lblockXn=false;}
	    else if(Math.cos(camera.rotation.y)<0){lblockXp=false;}
	}
	var restringeMXP = function (){
	    if(Math.sin(camera.rotation.y)>0){blockXp=false;}
	    else if(Math.sin(camera.rotation.y)<0){blockXn=false;}
	}
	var restringeMXPL = function (){
	    if(Math.cos(camera.rotation.y)>0){lblockXp=false;}
	    else if(Math.cos(camera.rotation.y)<0){lblockXn=false;}
	}
	    
	var collide = function (){
	  if (camera.position.z<-5){
		restringeMZN ();
		restringeMZNL ();
	  }

	  if (camera.position.x<-5){
		restringeMXN ();
		restringeMXNL ();
	  }

	  if (camera.position.z>5){
		restringeMZP ();
		restringeMZPL ();
	  }

	  if (camera.position.x>5){
		restringeMXP ();
		restringeMXPL ();
	  }
	  //collide azul
	  if (camera.position.z<-1&&camera.position.x<-1){
	    if (camera.position.x<-1.1){
		restringeMZN();
		restringeMZNL();
	    }
	    else if (camera.position.z<-1.1){
		restringeMXN();
		restringeMXNL();
	    }
	  }
	}
	 
	var movXn = function (){camera.position.x -=
		-Math.sin(-camera.rotation.y)*0.01;}
	var movXp = function (){camera.position.x +=
		-Math.sin(-camera.rotation.y)*0.01;}
	var movZn = function (){camera.position.z -=
		Math.cos(-camera.rotation.y)*0.01;}
	var movZp = function (){camera.position.z +=
		Math.cos(-camera.rotation.y)*0.01;}	
	var lmovXn = function (){camera.position.x -=
		Math.cos(camera.rotation.y)*0.01;}
	var lmovXp = function (){camera.position.x +=
		Math.cos(camera.rotation.y)*0.01;}
	var lmovZn = function (){camera.position.z -=
		-Math.sin(camera.rotation.y)*0.01;}
	var lmovZp = function (){camera.position.z +=
		-Math.sin(camera.rotation.y)*0.01;}	

	var animate = function(){
	  requestAnimationFrame(animate);
	  collide();
	    if (moverIzq){
		if (lblockXn){lmovXn();}
		if (lblockZn){lmovZn();}
	    }
	    if (moverDer){
		if (lblockXp){lmovXp();}
		if (lblockZp){lmovZp();}
	    }
	    if (moverAde){
		if (blockXn){movXn();}
		if (blockZn){movZn();}
	    }
	    if (moverAtr){
		if (blockXp){movXp();}
		if (blockZp){movZp();}
	    }
	    if (rotaIz){camera.rotation.y += Math.PI*0.001;}
	    if (rotaDe){camera.rotation.y -= Math.PI*0.001;}
	  renderer.render(scene,camera);
	//console.log(Math.sin(camera.rotation.y));
	//console.log(camera.position.x);
	}
	animate();

    </script>
  <body>
</html>
